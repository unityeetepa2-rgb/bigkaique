<!--
BIGKAIQUE ‚Äî Exemplo de sala coletiva de webcam (HTML + sinaliza√ß√£o WebSocket)

ATEN√á√ÉO: este exemplo demonstra como *pedir permiss√£o* a cada visitante e transmitir a webcam
para outros visitantes da mesma sala (estilo "big brother"). **Somente os usu√°rios que derem
permiss√£o ter√£o a c√¢mera transmitida.**

Voc√™ precisa de:
1) Este arquivo `index.html` (cliente) hospedado em HTTPS.
2) Um servidor de sinaliza√ß√£o (WebSocket) rodando em um servidor p√∫blico ‚Äî exemplo em Node.js
   est√° inclu√≠do abaixo como `server.js` (cole no servidor e rode com Node 18+).
3) Hospedar ambos (front-end em GitHub Pages, Netlify, etc., e o server.js em um VPS/Render/Heroku).

Privacidade: informe claramente aos usu√°rios que a c√¢mera ser√° transmitida e pe√ßa consentimento.
--> 

<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BIGKAIQUE ‚Äî Sala coletiva de Webcam</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto; background:#0b1220;color:#e6eef3;margin:0;padding:18px}
    header{display:flex;justify-content:space-between;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:12px}
    video{width:100%;height:160px;object-fit:cover;border-radius:8px;background:#000}
    .controls{display:flex;gap:8px;margin-top:8px}
    button{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .notice{background:#07202a;padding:10px;border-radius:8px;margin-top:10px}
  </style>
</head>
<body>
  <header>
    <h1>BIGKAIQUE ‚Äî Sala</h1>
    <div>
      <label>Nome da sala: <input id="roomInput" value="sala1" /></label>
      <button id="joinBtn">Entrar / Atualizar</button>
    </div>
  </header>

  <div class="notice">Este exemplo pede permiss√£o para enviar sua webcam. Apenas os participantes que
  permitirem ter√£o seu v√≠deo compartilhado com os demais. Use em HTTPS.</div>

  <div class="controls">
    <button id="startLocal">üî¥ Ativar minha c√¢mera</button>
    <button id="stopLocal" disabled>‚èπÔ∏è Desativar minha c√¢mera</button>
  </div>

  <div class="grid" id="videos"></div>

  <script>
  // CONFIG: alterar para o seu servidor de sinaliza√ß√£o (ws:// ou wss://)
  const SIGNALING_SERVER = 'wss://SEU_SERVIDOR_DE_SINALIZACAO:3000';

  // Mapa de peers
  const peers = new Map(); // peerId -> { pc, el }
  let localStream = null;
  let ws = null;
  let clientId = null;

  const videos = document.getElementById('videos');
  const startLocalBtn = document.getElementById('startLocal');
  const stopLocalBtn = document.getElementById('stopLocal');
  const joinBtn = document.getElementById('joinBtn');
  const roomInput = document.getElementById('roomInput');

  function log(...args){ console.log('[bigkaique]',...args); }

  function addVideo(id, stream, label){
    let container = document.getElementById('vid-'+id);
    if(!container){
      container = document.createElement('div');
      container.id = 'vid-'+id;
      const v = document.createElement('video');
      v.autoplay = true; v.playsInline = true; v.muted = false;
      container.appendChild(v);
      const cap = document.createElement('div'); cap.textContent = label || id; cap.style.fontSize='12px'; cap.style.marginTop='6px'; cap.style.color='#cfe';
      container.appendChild(cap);
      videos.appendChild(container);
    }
    const videoEl = container.querySelector('video');
    videoEl.srcObject = stream;
  }

  function removeVideo(id){
    const el = document.getElementById('vid-'+id);
    if(el) el.remove();
  }

  async function startLocal(){
    try{
      localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      addVideo('local', localStream, 'Voc√™ (local)');
      startLocalBtn.disabled = true; stopLocalBtn.disabled = false;
      // notify server we have local stream available
      send({type:'have-media'});
    }catch(e){
      alert('Erro ao acessar a c√¢mera: '+e.message);
    }
  }

  function stopLocal(){
    if(localStream){
      localStream.getTracks().forEach(t=>t.stop());
      localStream = null;
      removeVideo('local');
      startLocalBtn.disabled = false; stopLocalBtn.disabled = true;
      send({type:'no-media'});
    }
  }

  function connectWS(){
    if(ws) ws.close();
    ws = new WebSocket(SIGNALING_SERVER);
    ws.onopen = ()=>{ log('Conectado ao sinalizador'); send({type:'join', room: roomInput.value}); };
    ws.onmessage = async (ev)=>{ const msg = JSON.parse(ev.data); await handleSignal(msg); };
    ws.onclose = ()=>{ log('Sinalizador desconectado'); };
  }

  function send(msg){
    if(!ws || ws.readyState !== WebSocket.OPEN) return;
    if(!msg.from) msg.from = clientId;
    ws.send(JSON.stringify(msg));
  }

  async function handleSignal(msg){
    const {type, from, to, data, id} = msg;
    if(type === 'id'){
      clientId = msg.id; log('meu id', clientId);
    }else if(type === 'new-peer'){
      // criar PeerConnection e oferecer se queremos receber
      if(from === clientId) return;
      await createPeer(from, true);
    }else if(type === 'offer' && to === clientId){
      await createPeer(from, false);
      const p = peers.get(from).pc;
      await p.setRemoteDescription(new RTCSessionDescription(data));
      const answer = await p.createAnswer();
      await p.setLocalDescription(answer);
      send({type:'answer', to:from, data: p.localDescription});
    }else if(type === 'answer' && to === clientId){
      const p = peers.get(from).pc;
      await p.setRemoteDescription(new RTCSessionDescription(data));
    }else if(type === 'ice' && to === clientId){
      const p = peers.get(from).pc;
      try{ await p.addIceCandidate(data); }catch(e){ console.warn(e); }
    }else if(type === 'peer-left'){
      // remove
      if(peers.has(from)){
        peers.get(from).pc.close(); peers.delete(from); removeVideo(from);
      }
    }
  }

  async function createPeer(peerId, isOfferer){
    if(peers.has(peerId)) return;
    const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    peers.set(peerId, {pc});

    pc.onicecandidate = (e)=>{ if(e.candidate) send({type:'ice', to:peerId, data: e.candidate}); };
    pc.ontrack = (e)=>{ log('track from', peerId); const r = e.streams[0]; addVideo(peerId, r, 'Peer '+peerId); };

    // if we have local media, add tracks (so others see us)
    if(localStream){
      for(const t of localStream.getTracks()) pc.addTrack(t, localStream);
    }

    if(isOfferer){
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      send({type:'offer', to:peerId, data: pc.localDescription});
    }

    return pc;
  }

  // UI wiring
  startLocalBtn.onclick = startLocal;
  stopLocalBtn.onclick = stopLocal;
  joinBtn.onclick = ()=>{ connectWS(); };

  // connect on load (optional)
  // connectWS();
  </script>

  <!--
  -- server.js (Node.js simples para sinaliza√ß√£o via WebSocket)
  -- Cole esse arquivo em um servidor (por exemplo, VPS ou Render) e rode: node server.js
  -->
  <pre style="background:#001218;color:#cfe;padding:10px;border-radius:8px;margin-top:18px;overflow:auto">
  // server.js
  const WebSocket = require('ws');
  const wss = new WebSocket.Server({port:3000});
  const rooms = new Map();

  function send(ws, msg){ ws.send(JSON.stringify(msg)); }

  wss.on('connection', (ws)=>{
    ws.id = Math.random().toString(36).slice(2,9);
    ws.room = null;
    send(ws,{type:'id', id:ws.id});

    ws.on('message', (raw)=>{
      try{
        const msg = JSON.parse(raw);
        if(msg.type === 'join'){
          const room = msg.room || 'default';
          ws.room = room;
          if(!rooms.has(room)) rooms.set(room, new Set());
          const set = rooms.get(room);
          // notify existing peers about new peer
          set.forEach(peerWs=> send(peerWs,{type:'new-peer', from:ws.id}));
          // add to room
          set.add(ws);
        }else if(msg.type === 'have-media' || msg.type === 'no-media'){
          // broadcast to room if needed
        }else{
          // relay signaling messages (offer/answer/ice) to target
          const roomSet = rooms.get(ws.room) || new Set();
          roomSet.forEach(peerWs=>{
            if(peerWs.id === msg.to) send(peerWs,msg);
          });
        }
      }catch(e){ console.error(e); }
    });

    ws.on('close', ()=>{
      const room = ws.room;
      if(room && rooms.has(room)){
        const set = rooms.get(room);
        set.delete(ws);
        // notify remaining peers
        set.forEach(peerWs=> send(peerWs,{type:'peer-left', from:ws.id}));
      }
    });
  });
  </pre>

</body>
</html>
